//TOP DOWN APPROACH: O(n) time and O(n) space complexity
----------------------------------------------------------
[LINK](https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0)

#include<bits/stdc++.h>
int t[100001];//1d dp array
int topdown(vector<int> &heights, int n)
{
    //base case:
    if(n==0) //if no stair, then we need 0 minimum energy to reach the nth stair
    {
        return t[n] = 0;
    }
    //already computed
    if(t[n]!=-1)
    {
        return t[n];
    }
    //CHOICE1:
    //we compute the energy usd by frog to reach from nth to n-1 th step, then use recursion to compute the energy used by frog to reach from n-1 to 0th step
    int leftans = topdown(heights, n-1) + abs(heights[n]-heights[n-1]);
    //CHOICE2:
    //we compute the energy usd by frog to reach from nth to n-2 th step, then use recursion to compute the energy used by frog to reach from n-2 to 0th step[do this only if n>1, otherwise gives segmentation fault]
    int rightans = INT_MAX;
    if(n>1)
    {
        rightans = topdown(heights, n-2) + abs(heights[n]-heights[n-2]);
    }
    //we return the minimum of the two answers
    return t[n] = min(leftans,rightans);
}
int frogJump(int n, vector<int> &heights)
{
    // Write your code here.
    memset(t,-1,sizeof(t));
    return topdown(heights,n-1);
}
